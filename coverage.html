
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>postgres: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/braejan/go-transactions-summary/internal/domain/account/repository/postgres/account.go (76.7%)</option>
				
				<option value="file1">github.com/braejan/go-transactions-summary/internal/domain/user/entity/user.go (100.0%)</option>
				
				<option value="file2">github.com/braejan/go-transactions-summary/internal/domain/user/repository/postgres/user.go (100.0%)</option>
				
				<option value="file3">github.com/braejan/go-transactions-summary/internal/domain/user/usecases/user.go (100.0%)</option>
				
				<option value="file4">github.com/braejan/go-transactions-summary/internal/valueobject/postgres/base.go (0.0%)</option>
				
				<option value="file5">github.com/braejan/go-transactions-summary/internal/valueobject/postgres/postgres.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package postgres

import (
        "github.com/braejan/go-transactions-summary/internal/domain/account/entity"
        "github.com/braejan/go-transactions-summary/internal/domain/account/repository"
        "github.com/braejan/go-transactions-summary/internal/valueobject/account"
        "github.com/braejan/go-transactions-summary/internal/valueobject/postgres"
        "github.com/google/uuid"
)

// postgresAccountRepository struct implements the AccountRepository interface using
// a PostgreSQL database.
type postgresAccountRepository struct {
        configuration *postgres.PostgresConfiguration
        baseDB        postgres.PostgresDatabase
        repository.AccountRepository
}

// NewPostgresAccountRepository creates a new instance of postgresAccountRepository.
func NewPostgresAccountRepository(
        configuration *postgres.PostgresConfiguration,
        baseDB postgres.PostgresDatabase) (accountRepo repository.AccountRepository, err error) <span class="cov8" title="1">{
        if configuration == nil </span><span class="cov0" title="0">{
                err = postgres.ErrNilConfiguration
                return
        }</span>
        <span class="cov8" title="1">accountRepo = &amp;postgresAccountRepository{
                configuration: configuration,
                baseDB:        baseDB,
        }
        return</span>
}

// GetByID returns an account by its ID.
const (
        getAccountByID = `SELECT id, balance, userid, active FROM accounts WHERE id = $1`
)

func (postgresRepo *postgresAccountRepository) GetByID(ID uuid.UUID) (acc *entity.Account, err error) <span class="cov8" title="1">{
        db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">rows, err := postgresRepo.baseDB.Query(tx, getAccountByID, ID)
        if err != nil </span><span class="cov8" title="1">{
                err = account.ErrQueryingAccountByID
                return
        }</span>
        <span class="cov8" title="1">acc = &amp;entity.Account{}
        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;acc.ID, &amp;acc.Balance, &amp;acc.UserID, &amp;acc.Active)
                if err != nil </span><span class="cov8" title="1">{
                        err = account.ErrScanningAccountByID
                        return
                }</span>
        }
        <span class="cov8" title="1">if acc.UserID == 0 </span><span class="cov8" title="1">{
                err = account.ErrAccountNotFound
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetByUserID returns an account by its user ID.
const (
        getAccountByUserID = `SELECT id, balance, userid, active FROM accounts WHERE userid = $1`
)

func (postgresRepo *postgresAccountRepository) GetByUserID(userID int64) (acc *entity.Account, err error) <span class="cov8" title="1">{
        db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">rows, err := postgresRepo.baseDB.Query(tx, getAccountByUserID, userID)
        if err != nil </span><span class="cov8" title="1">{
                err = account.ErrQueryingAccountByUserID
                return
        }</span>
        <span class="cov8" title="1">acc = &amp;entity.Account{}
        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;acc.ID, &amp;acc.Balance, &amp;acc.UserID, &amp;acc.Active)
                if err != nil </span><span class="cov8" title="1">{
                        err = account.ErrScanningAccountByUserID
                        return
                }</span>
        }
        <span class="cov8" title="1">if acc.UserID == 0 </span><span class="cov8" title="1">{
                err = account.ErrAccountNotFound
        }</span>
        <span class="cov8" title="1">return</span>
}

// Create creates a new account.
const (
        createAccount = `INSERT INTO accounts (id, balance, userid, active) VALUES ($1, $2, $3, $4)`
)

func (postgresRepo *postgresAccountRepository) Create(acc *entity.Account) (err error) <span class="cov8" title="1">{
        if acc == nil </span><span class="cov8" title="1">{
                err = account.ErrNilAccount
                return
        }</span>
        <span class="cov8" title="1">db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">_, err = postgresRepo.baseDB.Exec(tx, createAccount, acc.ID, acc.Balance, acc.UserID, acc.Active)
        if err != nil </span><span class="cov8" title="1">{
                _ = postgresRepo.baseDB.Rollback(tx)
                err = account.ErrCreatingAccount
                return
        }</span>
        <span class="cov8" title="1">err = postgresRepo.baseDB.Commit(tx)
        return</span>
}

// Update updates an account.
const (
        updateAccount = `UPDATE accounts SET balance = $1, active = $2 WHERE id = $3`
)

func (postgresRepo *postgresAccountRepository) Update(acc *entity.Account) (err error) <span class="cov0" title="0">{
        if acc == nil </span><span class="cov0" title="0">{
                err = account.ErrNilAccount
                return
        }</span>
        <span class="cov0" title="0">db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov0" title="0">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov0" title="0">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov0" title="0">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov0" title="0">_, err = postgresRepo.baseDB.Exec(tx, updateAccount, acc.Balance, acc.Active, acc.ID)
        if err != nil </span><span class="cov0" title="0">{
                _ = postgresRepo.baseDB.Rollback(tx)
                err = account.ErrUpdatingAccount
        }</span>
        <span class="cov0" title="0">err = postgresRepo.baseDB.Commit(tx)
        return</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package entity

// User struct represent the card user entity.
type User struct {
        ID    int64  `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

// NewUser creates a new user instance using factory pattern.
func NewUser(ID int64, name string, email string) (user *User) <span class="cov8" title="1">{
        return &amp;User{
                ID:    ID,
                Name:  name,
                Email: email,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package postgres

import (
        "log"

        "github.com/braejan/go-transactions-summary/internal/domain/user/entity"
        "github.com/braejan/go-transactions-summary/internal/domain/user/repository"
        "github.com/braejan/go-transactions-summary/internal/valueobject/postgres"
        userErrors "github.com/braejan/go-transactions-summary/internal/valueobject/user"
        _ "github.com/lib/pq"
)

// postgresUserRepository struct implements the UserRepository interface using
// a PostgreSQL database.
type postgresUserRepository struct {
        configuration *postgres.PostgresConfiguration
        baseDB        postgres.PostgresDatabase
        repository.UserRepository
}

// NewPostgresUserRepository creates a new instance of postgresUserRepository.
func NewPostgresUserRepository(configuration *postgres.PostgresConfiguration, baseDB postgres.PostgresDatabase) (userRepo repository.UserRepository, err error) <span class="cov8" title="1">{
        if configuration == nil </span><span class="cov8" title="1">{
                err = postgres.ErrNilConfiguration
                return
        }</span>
        <span class="cov8" title="1">userRepo = &amp;postgresUserRepository{
                configuration: configuration,
                baseDB:        baseDB,
        }
        return</span>
}

// GetByID returns a user by its ID.
const (
        getUserByID = `SELECT id, name, email FROM users WHERE id = $1`
)

func (postgresRepo *postgresUserRepository) GetByID(ID int64) (user *entity.User, err error) <span class="cov8" title="1">{
        db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">rows, err := postgresRepo.baseDB.Query(tx, getUserByID, ID)
        if err != nil </span><span class="cov8" title="1">{
                err = userErrors.ErrQueryingUserByID
                return
        }</span>
        <span class="cov8" title="1">user = &amp;entity.User{}
        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("error scanning user row: %v", err)
                        user = nil
                        err = userErrors.ErrScanningUserByID
                        return
                }</span>
        }
        <span class="cov8" title="1">if user.ID == 0 &amp;&amp; user.Name == "" &amp;&amp; user.Email == "" </span><span class="cov8" title="1">{
                user = nil
                err = userErrors.ErrUserNotFound
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetByEmail returns a user by its email.
const (
        getUserByEmail = `SELECT id, name, email FROM users WHERE email = $1`
)

func (postgresRepo *postgresUserRepository) GetByEmail(email string) (user *entity.User, err error) <span class="cov8" title="1">{
        db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">rows, err := postgresRepo.baseDB.Query(tx, getUserByEmail, email)
        if err != nil </span><span class="cov8" title="1">{
                err = userErrors.ErrQueryingUserByEmail
                return
        }</span>
        <span class="cov8" title="1">user = &amp;entity.User{}
        if rows.Next() </span><span class="cov8" title="1">{
                err = rows.Scan(&amp;user.ID, &amp;user.Name, &amp;user.Email)
                if err != nil </span><span class="cov8" title="1">{
                        user = nil
                        err = userErrors.ErrScanningUserByEmail
                        return
                }</span>
        }
        <span class="cov8" title="1">if user.ID == 0 &amp;&amp; user.Name == "" &amp;&amp; user.Email == "" </span><span class="cov8" title="1">{
                user = nil
                err = userErrors.ErrUserNotFound
        }</span>
        <span class="cov8" title="1">return</span>
}

// Create creates a new user.
const (
        createUser = `INSERT INTO users (id, name, email) VALUES ($1, $2, $3)`
)

func (postgresRepo *postgresUserRepository) Create(user *entity.User) (err error) <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                err = userErrors.ErrNilUser
                return
        }</span>
        <span class="cov8" title="1">db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">_, err = postgresRepo.baseDB.Exec(tx, createUser, user.ID, user.Name, user.Email)
        if err != nil </span><span class="cov8" title="1">{
                _ = postgresRepo.baseDB.Rollback(tx)
                err = userErrors.ErrCreatingUser
                return
        }</span>
        <span class="cov8" title="1">err = postgresRepo.baseDB.Commit(tx)
        return</span>
}

// Update updates a user.
const (
        updateUser = `UPDATE users SET name = $1, email = $2 WHERE id = $3`
)

func (postgresRepo *postgresUserRepository) Update(user *entity.User) (err error) <span class="cov8" title="1">{
        if user == nil </span><span class="cov8" title="1">{
                err = userErrors.ErrNilUser
                return
        }</span>
        <span class="cov8" title="1">db, err := postgresRepo.baseDB.Open(postgresRepo.configuration.GetDataSourceName())
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrOpeningDatabase
                return
        }</span>
        <span class="cov8" title="1">defer postgresRepo.baseDB.Close(db)
        tx, err := postgresRepo.baseDB.BeginTx(db)
        if err != nil </span><span class="cov8" title="1">{
                err = postgres.ErrBeginningTransaction
                return
        }</span>
        <span class="cov8" title="1">_, err = postgresRepo.baseDB.Exec(tx, updateUser, user.Name, user.Email, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                _ = postgresRepo.baseDB.Rollback(tx)
                err = userErrors.ErrUpdatingUser
                return
        }</span>
        <span class="cov8" title="1">err = postgresRepo.baseDB.Commit(tx)
        return</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package usecases

import (
        "github.com/braejan/go-transactions-summary/internal/domain/user/entity"
        "github.com/braejan/go-transactions-summary/internal/domain/user/repository"
        "github.com/braejan/go-transactions-summary/internal/valueobject/user"
)

// userUsecases struct implements the UserUsecases interface.

type userUsecases struct {
        userRepo repository.UserRepository
}

// NewUserUsecases returns a new userUsecases instance.
func NewUserUsecases(userRepo repository.UserRepository) (usecases UserUsecases, err error) <span class="cov8" title="1">{

        if userRepo == nil </span><span class="cov8" title="1">{
                err = user.ErrUserRepositoryIsNil
                return
        }</span>
        <span class="cov8" title="1">usecases = &amp;userUsecases{
                userRepo: userRepo,
        }
        return</span>
}

// GetByID implements the UserUsecases interface method.
func (u *userUsecases) GetByID(ID int64) (user *entity.User, err error) <span class="cov8" title="1">{
        user, err = u.userRepo.GetByID(ID)
        return
}</span>

// GetByEmail implements the UserUsecases interface method.
func (u *userUsecases) GetByEmail(email string) (user *entity.User, err error) <span class="cov8" title="1">{
        user, err = u.userRepo.GetByEmail(email)
        return
}</span>

// Create implements the UserUsecases interface method.
func (u *userUsecases) Create(ID int64, name string, email string) (err error) <span class="cov8" title="1">{
        _, err = u.userRepo.GetByID(ID)
        if err == user.ErrUserNotFound </span><span class="cov8" title="1">{
                // The user is not created.
                err = u.userRepo.Create(entity.NewUser(ID, name, email))
        }</span> else<span class="cov8" title="1"> if err == nil </span><span class="cov8" title="1">{
                // The user is already created.
                err = user.ErrUserAlreadyCreated
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

// Update implements the UserUsecases interface method.
func (u *userUsecases) Update(ID int64, name string, email string) (err error) <span class="cov8" title="1">{
        _, err = u.userRepo.GetByID(ID)
        if err != nil </span><span class="cov8" title="1">{
                // The user is not created.
                err = user.ErrUserNotFound
                return
        }</span>
        <span class="cov8" title="1">err = u.userRepo.Update(entity.NewUser(ID, name, email))
        return</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package postgres

import (
        "context"
        "database/sql"
)

// basePostgresDatabase is the base implementation of PostgresDatabase interface.
type basePostgresDatabase struct{}

// NewBasePostgresDatabase creates a new instance of PostgresDatabase interface implementation.
func NewBasePostgresDatabase() PostgresDatabase <span class="cov0" title="0">{
        return &amp;basePostgresDatabase{}
}</span>

// PostgresDatabase interface implementation.

// Open opens a new database connection.
func (postgresRepo *basePostgresDatabase) Open(dataSourceName string) (db *sql.DB, err error) <span class="cov0" title="0">{
        db, err = sql.Open("postgres", dataSourceName)
        return
}</span>

// Close closes a database connection.
func (postgresRepo *basePostgresDatabase) Close(db *sql.DB) (err error) <span class="cov0" title="0">{
        err = db.Close()
        return
}</span>

// Begin begins a transaction.
func (postgresRepo *basePostgresDatabase) BeginTx(db *sql.DB) (tx *sql.Tx, err error) <span class="cov0" title="0">{
        tx, err = db.BeginTx(context.Background(), nil)
        return
}</span>

// Commit commits a transaction.
func (postgresRepo *basePostgresDatabase) Commit(tx *sql.Tx) (err error) <span class="cov0" title="0">{
        err = tx.Commit()
        return
}</span>

// Rollback rollbacks a transaction.
func (postgresRepo *basePostgresDatabase) Rollback(tx *sql.Tx) (err error) <span class="cov0" title="0">{
        err = tx.Rollback()
        return
}</span>

// Exec executes a sql instruction.
func (postgresRepo *basePostgresDatabase) Exec(tx *sql.Tx, dml string, args ...interface{}) (result sql.Result, err error) <span class="cov0" title="0">{
        result, err = tx.ExecContext(context.Background(), dml, args...)
        return
}</span>

// Query executes a sql query.
func (postgresRepo *basePostgresDatabase) Query(tx *sql.Tx, query string, args ...interface{}) (rows *sql.Rows, err error) <span class="cov0" title="0">{
        rows, err = tx.QueryContext(context.Background(), query, args...)
        return
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package postgres

import (
        "database/sql"
        "os"
        "strconv"
)

type PostgresDatabase interface {
        Open(dataSourceName string) (db *sql.DB, err error)
        Close(db *sql.DB) (err error)
        BeginTx(db *sql.DB) (tx *sql.Tx, err error)
        Commit(tx *sql.Tx) (err error)
        Rollback(tx *sql.Tx) (err error)
        Exec(tx *sql.Tx, query string, args ...interface{}) (result sql.Result, err error)
        Query(tx *sql.Tx, query string, args ...interface{}) (rows *sql.Rows, err error)
}

type PostgresConfiguration struct {
        Host     string
        Port     int
        User     string
        Password string
        Database string
}

func NewPostgresConfiguration(host string, port int, user string, password string, database string) (configuration *PostgresConfiguration) <span class="cov0" title="0">{
        configuration = &amp;PostgresConfiguration{
                Host:     host,
                Port:     port,
                User:     user,
                Password: password,
                Database: database,
        }
        return
}</span>

func GetDefaultPostgresConfiguration() (configuration *PostgresConfiguration) <span class="cov0" title="0">{
        configuration = &amp;PostgresConfiguration{
                Host:     "localhost",
                Port:     5432,
                User:     "postgres",
                Password: "postgres",
                Database: "stori-challenge-db",
        }
        return
}</span>

func GetPostgresConfigurationFromEnv() (configuration *PostgresConfiguration) <span class="cov0" title="0">{
        host := os.Getenv("POSTGRES_HOST")
        if host == "" </span><span class="cov0" title="0">{
                // return default configuration
                return GetDefaultPostgresConfiguration()
        }</span>
        <span class="cov0" title="0">port, err := strconv.Atoi(os.Getenv("POSTGRES_PORT"))
        if err != nil </span><span class="cov0" title="0">{
                // return default configuration
                return GetDefaultPostgresConfiguration()
        }</span>
        <span class="cov0" title="0">user := os.Getenv("POSTGRES_USER")
        password := os.Getenv("POSTGRES_PASSWORD")
        database := os.Getenv("POSTGRES_DATABASE")

        configuration = &amp;PostgresConfiguration{
                Host:     host,
                Port:     port,
                User:     user,
                Password: password,
                Database: database,
        }
        return</span>
}

func (configuration *PostgresConfiguration) GetDataSourceName() (dataSourceName string) <span class="cov0" title="0">{
        dataSourceName = "host=" + configuration.Host
        dataSourceName += " port=" + strconv.Itoa(configuration.Port)
        dataSourceName += " user=" + configuration.User
        dataSourceName += " password=" + configuration.Password
        dataSourceName += " dbname=" + configuration.Database
        dataSourceName += " sslmode=disable"
        return
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
